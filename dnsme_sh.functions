#!/bin/bash

function dnsme_api () {

local api_url=https://api.dnsmadeeasy.com
[[ x$sandbox == x1 ]] && api_url=https://api.sandbox.dnsmadeeasy.com

dnsme_throttle # Checking that the request rate is not exceeded

request_date=$(
{ echo -n "$(date -u -R) " ; date -u +%Z ; } | cut -s -d' ' -f1-5,7
)

hmac=$(echo -n "$request_date" | openssl sha1 -hmac "$dnsme_secret_key" | sed 's/.*= //g')

# http headers
api_key_H="x-dnsme-apiKey:$dnsme_api_key"
hmac_H="x-dnsme-hmac:$hmac"
req_date_H="x-dnsme-requestDate:$request_date"
content_type_H="content-type:application/json"
accept_type_H="accept:application/json"
local url=$1
shift
url=$api_url/${url#*dnsmadeeasy.com/} # backward compatibility for calls that use full url instead of uri

local src args msgs
args=$(echo $url $*)
api_history=$(api_history)
res=$(curl -k -s -S -H "$api_key_H" -H "$hmac_H" -H "$req_date_H" -H "$content_type_H" -H "$accept_type_H" $url "$@" 2>&1 )
res_code=$?
if ! [[ x$res_code == x0 ]] ; then
	res_code=$(( $? + 10 ))
	echo -e " res code: $res_code \n src: $api_history \n args: $args \n msgs: Curl failed: $res"  | error_red
	return $res_code
fi

if [[ -z $res ]] ; then
	res=$(echo -e " src: $src \n msgs: Sucess. No curl output" )
	return $res_code
fi

# For some reason dnsme returns errors as jq filter instead of json	
if jq -n -e "$(echo $res | cut -c 1-333) | .error"  >/dev/zero 2>&1 ; then
local logic='
	Reconstructing error can save you a lot of time troubleshooting'
	res_code=1
	echo -e " res code: $res_code \n src: $api_history \n args: $args \n msgs: $res" | error_red
	return $res_code
fi

if ! echo $res | is_json ; then
	res_code=2
	echo -e "res_code: $res_code \n src: $api_history \n args: $args \n msgs: Request failed. Response is not json" | error_red
    echo $res | 
	if echo $res | fgrep -q '</html>' ; then
		 lynx -dump --stdin 1>&2
	else
		cat
	fi | error_red
    return $res_code
fi

} # end function

function dnsme_throttle () {
local LIMIT=150 FRAME=5 # Request limit is 150 per 5 min

local reqs=$(find  $dnsme_work_dir -name req_ts* | sort -r)
if (( $(echo $reqs | wc -w ) < 149 )) ; then
	touch $dnsme_work_dir/req_ts.$(date +%s)
	return 0
fi

echo $reqs | cut -d \   -f 150- | xargs rm -f
local start=$(echo $reqs | cut -d " " -f 149 | egrep -o [0-9]+$)
local frame_end=$(( start + FRAME*60 ))
if (( frame_end > $(date +%s) )) ; then
	local secs_wait=$(( frame_end - $(date +%s) ))
	echo -e " src: $(api_history) \n msg: Rate limit exceeded. Waiting $secs_wait seconds \n time: $(date)" | error_green
	sleep $secs_wait
fi
touch $dnsme_work_dir/req_ts.$(date +%s)
}

function dnsme_domain_status () {
	local domain=$1 id
	[[ -n $domain ]] || return 255
	if [[ x$domain =~ ^x[0-9]+$ ]] ; then
		dnsme api V2.0/dns/managed/$domain
	else
		dnsme api V2.0/dns/managed/id/$domain
	fi || return
	echo $res | json2bash
} # end function
	
function dnsme_domain_id () {
	res=$(cat $dnsme_cache | 
	jq -e --arg domain $1 '.data[] | select(.name==$domain or (.id|tostring)==$domain)| {id,updated,name}')

	if ! [[ x$? == x0 ]] ; then
		echo -e " src: $(api_history) \n msgs: Domain ${1:-Null} not found" | error_green
		return 1
	fi
	echo $res | json2table
}

function dnsme_purge () {
# purge deleted domains
local domains cached_domains
domains=$( dnsme ls | awk '{print $3}' | sed 1d )
cached_domains=$( find $dnsme_domains_dir/* | egrep -v 'dnsme.domains')
diff -Bb  <( echo "$domains")  <(echo "$cached_domains")  --suppress-common-lines  |
egrep '^>' | awk '{print $2}' | xargs -L 1 /bin/rm -fv
}

function dnsme_cfg () {
[[ x$1 == xreset ]] && unset dnsme_api_key dnsme_secret_key
[[ -z $dnsme_api_key ]] && read -p 'API Key: ' dnsme_api_key
[[ -z $dnsme_secret_key ]] && read -s -p 'API Secret Key: ' dnsme_secret_key && echo
} # end function dnsme_configure

function dnsme_url () {
local domain_id=$1
echo https://cp.dnsmadeeasy.com/dns/managed/$domain_id
}

function dnsme_updatedb () {
if [[ -z $1 ]] ; then
	dnsme_api V2.0/dns/managed && echo $res > $dnsme_cache
	return
	# Will return with error of dnsme_api, if dnsme_api fails
fi

local name serial id
read id serial name < <(dnsme domain id $1)
[[ x$id =~ ^x[0-9]+$ ]] || return 1
local domain_cache=$dnsme_domains_dir/$name
dnsme_api V2.0/dns/managed/$id/records && echo $res > $domain_cache
}

function dnsme_cat () {
if [[ -z $1 ]] ; then  
	if ! cat $dnsme_cache | is_json ; then
		dnsme updatedb
	fi
	res=$(<$dnsme_cache)
	cat $dnsme_cache
	return
fi

local domain=$1 id serial
read id serial domain < <(dnsme domain id $domain)
[[ x$id =~ ^x[0-9]+$ ]] || return 1
local domain_cache=$dnsme_domains_dir/$domain
if ! cat $domain_cache | is_json ; then
	dnsme updatedb $domain
fi
res=$(<$domain_cache)
cat $domain_cache
}

function dnsme_ls () {

if [[ -z $1 || x$1 == xdomains ]] ; then  
	dnsme cat |
	{ 
	to_array "Domain Id" Serial "Domain name" ;
	jq -r ' .data | sort_by("name") | .[] | 
	{ id , updated, name }' ;
	} | json2table

	return
fi

if [[ x$1 == xcache ]] ; then
	grep -l 'type' $dnsme_domains_dir/*
	return
fi

local domain
domain=$1
shift
dnsme cat $domain |
if [[ -z $1 ]] ; then  
	{
	to_array Id Name Type TTL Rdata Value ;
	# The next jq take input from the pipe
	jq -r '.data | sort_by(.type) | .[] |
	if .name == "" then .name="@" else . end |
	{ id , name, type, ttl,
	rdata: (
	{weight,priority,port,mxLevel} | 
	[ to_entries[] |
	if .value|type=="number" then .key + "=" + (.value|tostring) else empty end ] | 
	if length > 0 then join(",") else "-" end
	),
	value }' ; 
	} | json2table
else
	jq -c '.data[]|select((.id|tostring)=="'$1'")' | json2bash
fi
} # end function 

function dnsme () {

# export dnsme_debug=off

dnsme_work_dir=/dev/shm/$USER/dnsme
dnsme_domains_dir=/dev/shm/$USER/dnsme/domains
dnsme_cache=$dnsme_domains_dir/dnsme.domains
dnsme_work_dir=$dnsme_work_dir/run
mkdir -p $dnsme_work_dir $dnsme_domains_dir

dnsme_cfg

local action=$1
shift
case x$action in
	xdomain|xrecord|xcache)
		action=${action}_$1
		shift
		dnsme_$action "$@" 
		# dnsme ls cache -> dnsme_ls_cache
		# dnsme domain rm 12345 -> dnsme_domain_rm 12345
	;;
	x)
		return
	;;
	*)
		dnsme_$action "$@" 
		# dnsme ls -> dnsme_ls
		# dnsme ls 12345 -> dnsme_ls 12345
	;;
esac	
} # end function dnsme
